using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using UnityEngine.EventSystems;
using UnityEngine.Events;


public class Player : MonoBehaviour
{
	

	[SerializeField] private GameObject gameOverMenu;
	[SerializeField] private GameObject mainMenu;
	[SerializeField] private GameObject secondStartPoint;
	[SerializeField] private MeterCounter meterCounter;
	private Transform playerСoordinates;
	private float speed;
	[SerializeField] private float distanceGravit = 7;
	private Image HealthImage;

	public float PlayerSpeed=100;
		
	[SerializeField] private ShotGun shot;
	public Transform StartPoint;
	public Animator Player_Anim;
	public float TimeBeReady = 3;
	[SerializeField] private SpawnManager spawnManager;
	private RaycastHit hit;
	

	public Text TextTimeToStart;
	[SerializeField] private Slider HealthSlider;


	 

	[SerializeField] private Sprite Play, Stop;
	[SerializeField] private ParticleSystem ParticleInCoin;
	[HideInInspector] public Rigidbody rb;
	public Image PauseImage;

	private bool isGameOver;
    public bool IsGameOver { get => isGameOver;}

	private bool isPauseOn = false;

    public bool IsPauseOn { get => isPauseOn;}

	public AdvertistGoing SliderAdver;

	public Text MetersOnMenu;

	[SerializeField] private GameObject ButtonHealth;
	private Text TextHealth;

	private bool paused = true;
	public bool Paused { get => paused; }

	private float BufferPlayerSpeed;

	private ParticleSystem ParticleReBorn;

	[SerializeField] private GameObject ClicPlatform;


	private int QuantityHealth;

	private List<Collider> EnemiesCol = new List<Collider>();


	private void Start()
	{
		 
		HealthImage = HealthSlider.transform.GetChild(1).GetChild(0).GetComponent<Image>();

		playerСoordinates = GetComponent<Transform>();
		 
		EventManager.EventPlay?.Invoke(100);
		
		EventManager.Animation_Play?.Invoke(true);

		Player_Anim.SetBool("Die", false);

		TextHealth = ButtonHealth.transform.GetChild(0).GetComponent<Text>();

		QuantityHealth = PlayerPrefs.GetInt("Heart");

		if (QuantityHealth < 1) ButtonHealth.GetComponent<Button>().interactable = false;
			
		TextHealth.text = PlayerPrefs.GetInt("Heart").ToString();

		isGameOver = false;

		

	}
	private Button ButtonHeart;
	
		 
	
	 
    public void False()//метод добавляет Rigidbody после анимации поворота и передает скорость в аниматор
	{
		Player_Anim.SetBool("PlayIsPressed", false);
		Player_Anim.SetFloat("Speed", 40);

		gameObject.AddComponent<Rigidbody>();
		 
		rb = gameObject.GetComponent<Rigidbody>();
		rb.freezeRotation = true;
		rb.useGravity = false;
		Player_Anim.applyRootMotion = false; //замораживаем повороты и перемещения анимаций после поворота нашей первой анимации

		if (gameObject.transform.rotation.y > 0) // если наш персонаж до конца не развернулся - разворачиваем его до конца
		{
			transform.rotation = Quaternion.Euler(transform.rotation.x, 0, transform.rotation.z);
			 
		
		}
	}
	 
	public void GameOver()//метод, отвечающий за конец игры
	{
		ClicPlatform.SetActive(false);

		Player_Anim.SetFloat("Speed", 0); 

		MetersOnMenu.text = string.Format($"{meterCounter.meterCount}");

		if (PlayerSpeed > 0) // так как колайдер вывзывается несколько раз - BufferSpeed Обнуляется
		{
			BufferPlayerSpeed = PlayerSpeed;
		}

		PlayerSpeed = 0;

		EventManager.SetSpeedCar?.Invoke(0);

		

		StopAllCoroutines();//останавливаем увеличичение  скорости игры

		ButtonHeart.interactable = false;

		isGameOver = true;

	




	




	}
 
	public void UseHealth()// увеличиваем жизнь за счет купленных сердечек
	{
	 

		 

		EventManager.ButtonClicked.Invoke();

		if (QuantityHealth > 0)
		{

			
		 

			PlayerPrefs.SetInt("Heart", QuantityHealth -= 1);

			TextHealth.text = QuantityHealth.ToString();

			HealthAfterPunch += 0.5f;

			CheckColorHealth();

		}

		else //если жизни закончились - деактивируем кнопочку
		{
		TextHealth.text = "0";

		ButtonHeart.interactable = false;
		
		}
	
	}

	public void Velocity_Null()
	{
		 

	 

		gameOverMenu.SetActive(true);
		 



		

		StartCoroutine(SliderAdver.IncreaseSlider());



	}
	float HealthAfterPunch;
	 
	private void Awake()
	{
		HealthAfterPunch = HealthSlider.value;
		StartCoroutine(IncreaseGame());//увеличиваем постепенно скорость игры

		StartCoroutine(meterCounter.MeterCounterCoroutine());//включение счётчика метров      
		StartCoroutine(meterCounter.MeterCounterSpeedCoroutine());//постепенное увеличение счётчика метров
		

		Time.timeScale = 1;

		EventManager.AdvertisIsShowed.AddListener(RewardPlayer);// подписка на награду за рекламу

		ButtonHeart = ButtonHealth.GetComponent<Button>();

	}

	public void ButtonExitToMainMenu()
	{

		SceneManager.LoadScene(0);
		gameOverMenu.SetActive(false);
		playerСoordinates.transform.position = secondStartPoint.transform.position;
		HealthSlider.value = 1;

		DontDestroyOnLoad(gameObject); /* юнити ссылается на события из скрипта которые в выключенном состоянии во время добавления новой сцены.
		                                * Поэтому мы не удаляем игрока а переносим его на новую сцену чтобы не возникало ошибок.Однако в новой сцене у нас будет 2 персонажа одновременно.
		                              * Поэтому удаляем лишнего из них*/
		Destroy(gameObject, 0.1f);
	
	}



	private void OnCollisionExit(Collision other)
	{
		if (other.transform.tag == "MetalObstacle" || other.transform.tag == "Car" || other.transform.tag == "Obstacle")
		{
			speed = 0;
		}
	}
	 
	
    private void OnCollisionEnter(Collision other)
    {
		if (other.transform.tag == "Coin"||other.transform.tag == "GoldCoin")
			
        { 
            Instantiate(ParticleInCoin, other.transform.position + new Vector3(0, 8f, 0), other.transform.rotation);//при соприкосновении коллайдера игрока с монеткой появляется дымка от исчезнувшей монеты
			Destroy(other.gameObject);
            if (EventManager.PickUpCoinEvent != null) EventManager.PickUpCoinEvent.Invoke(other.gameObject);
			if (EventManager.AudioCoinEvent != null) EventManager.AudioCoinEvent.Invoke();
        }
		 

		if (other.transform.tag == "MetalObstacle" || other.transform.tag == "Car"|| other.transform.tag == "Obstacle"||other.transform.tag=="Gas")
		{
			
			HealthAfterPunch = HealthSlider.value - EventManager.IsPunched.Invoke();// меняем значение здоровья игрока вызывая событие

	 

			Destroy(other.gameObject.GetComponent<BoxCollider>());

			Destroy(other.gameObject, 0.6f);// удаляем врага через 0.6 секунды

			 


			
			
			 
			
			
			if (other.gameObject.tag != "Gas") // запускаем анимацию спотыкания
			{

				Player_Anim.SetTrigger("Punched");
			}

			if (HealthSlider.value <= 0.1) // проверяем уровень жизни чтобы понять завершать ли игровую сессию
			{
				 

				Player_Anim.SetTrigger("Die");

				 

				GameOver();// переключаем на анимацию смерти  
				
			}


			CheckColorHealth();
		 



		}
		 
		 
	}

	 
 





	private void OnEnable()
	{
		EventManager.EventPlay += StartRunValues;

		EventManager.Animation_Play += Set_Anim_Play_True;

	 


	}
	void OnDisable()
	{
		EventManager.EventPlay -= StartRunValues;

		EventManager.Animation_Play -= Set_Anim_Play_True;

	 


	}
	 
	private void FixedUpdate()
	{

	 
		HealthSlider.value = Mathf.MoveTowards(HealthSlider.value, HealthAfterPunch, 0.6f*Time.fixedDeltaTime);// плавное снижене здоровья после удара

		StartRunValues(PlayerSpeed);

		Physics.Raycast(transform.position, Vector3.down, out hit); //создаем луч для проверки

		if (hit.distance > distanceGravit && (hit.transform.tag.Equals("Road") || hit.transform.tag.Equals("Obstacle"))
			&& rb != null) // если мы прыгнули выше высоты
						   // прыжка и под нами дорога или препятствие - тогда падаем
		{


			rb.velocity = Vector3.zero;
			rb.velocity = -transform.up * Time.deltaTime * 15_000;



		}
		else if (rb != null && hit.distance < distanceGravit) // если мы на земле
		{

			rb.velocity = new Vector3(0, 0, speed);// обнуляем ускорение

		}
	}

	private void StartRunValues(float GameSpeed)
	{
		
 
		transform.Translate(0, 0, GameSpeed * Time.deltaTime, Space.World);

	 
	}

 

	public void Pause()
	{

		EventManager.ButtonClicked.Invoke();//звук
		if (paused)
		{
			BufferPlayerSpeed = PlayerSpeed;//сохраняем значение скорости
			PlayerSpeed = 0;//придаем ноль скорости
			Player_Anim.SetFloat("Speed",0);
			paused = false;
			PauseImage.sprite = Stop;
			StopAllCoroutines();//останавливаем ускорение игры
			isPauseOn = true;
			EventManager.SetSpeedCar.Invoke(0f);// останавливаем машины

	

				}
		else
		{


			StartCoroutine(PauseReset());

			TextTimeToStart.gameObject.SetActive(true);

			
			PauseImage.sprite = Play;

			 
		   paused = true;
			

		}

	}
 


	public void Include_to_Run()
	{
		Player_Anim.SetBool("MoveRight", false);
		Player_Anim.SetBool("MoveLeft", false);
		 
	}
	 
	IEnumerator PauseReset()
	{
		float TimeStart = Time.time;
		float TimeToGo = Time.time + TimeBeReady;
		while (TimeStart < TimeToGo) //3 секунды до старта игры
		{
			TimeStart = Time.time;
			TextTimeToStart.text = (TimeToGo - TimeStart).ToString();


			yield return null;
			
		}
	


		TextTimeToStart.gameObject.SetActive(false) ;
		StopCoroutine(PauseReset());

		PlayerSpeed = BufferPlayerSpeed;//снова придаем телу данную ему скорость 
		Player_Anim.SetFloat("Speed", 50);

		isPauseOn = false;
		StartCoroutine(IncreaseGame());

		StartCoroutine(meterCounter.MeterCounterCoroutine());//включение счётчика метров
		StartCoroutine(meterCounter.MeterCounterSpeedCoroutine());//постепенное увеличение счётчика метров

		 

		EventManager.SetSpeedCar.Invoke(200f);//обратно придаем скорость машинам

	}

	private IEnumerator IncreaseGame()//метод отвечающий за постепенное увеличение скорости игры
	{

		while (true)
		{

			yield return new WaitForSeconds(4f);
			PlayerSpeed += 3;

		}
	}
	

	private void Set_Anim_Play_True(bool b)
	{
		

		Player_Anim.SetBool("PlayIsPressed", b);

	}

	
	 
	 
	 
	public void StartShot()
	{
		shot.Shot();
	}

	

	public void OnDrag(PointerEventData eventData)
	{
		
	}
	void Get_Speed()


		=> speed = 300;



	void ResetSpeed()

		=> speed = 0;

	private void CheckColorHealth()
	{
	 

		if (HealthAfterPunch < 0.7 && HealthAfterPunch > 0.3) HealthImage.color = Color.yellow;

		if (HealthAfterPunch < 0.3f) HealthImage.color = Color.red;

		if (HealthAfterPunch >= 0.9f)
		{
			ButtonHeart.interactable = false;
			HealthImage.color = Color.green;
		}
		else if (HealthAfterPunch < 0.9 && HealthAfterPunch > 0.1f)
			ButtonHeart.interactable = true;
	
		
		
	}

	public void RewardPlayer()
	{

		Time.timeScale = 1;

		ClicPlatform.SetActive(true);

		PlayerSpeed = BufferPlayerSpeed;

		ParticleReBorn = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();

		ParticleReBorn.Play();

		Player_Anim.SetTrigger("ReBorn");

		Player_Anim.SetFloat("Speed",PlayerSpeed);

		EventManager.SetSpeedCar?.Invoke(200);

		HealthAfterPunch = 1;

		StartCoroutine(IncreaseGame());//останавливаем увеличичение  скорости игры

		CheckColorHealth();

		gameOverMenu.SetActive(false);

		isGameOver = false;
		StartCoroutine(meterCounter.MeterCounterCoroutine());//включение счётчика метров      
		StartCoroutine(meterCounter.MeterCounterSpeedCoroutine());//постепенное увеличение счётчика метров

		EnemiesCol.AddRange(Physics.OverlapSphere(gameObject.transform.position, 800));// добавляем всех врагов в радиусе 1000 метров и удвляем их

		foreach (var Enemy in EnemiesCol)
		{
			if(Enemy.gameObject.CompareTag("Car") 
				|| Enemy.gameObject.CompareTag("MetalObstacle") 
				|| Enemy.gameObject.CompareTag("Obstacle") 
				|| Enemy.gameObject.CompareTag("Gas"))

			Destroy(Enemy.gameObject);

		 
		
		}




	}

		 
}




